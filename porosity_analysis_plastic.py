# -*- coding: utf-8 -*-
"""porosity_analysis_plastic.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vrb8hRezdVAEE7hk_4ERxnHV1kpV6qTe

# Microstructure porosity analysis based on computer vision
"""

# Import the necessary libraries for image processing, statistical analysis, and visualization
import numpy as np
import pandas as pd
import cv2

import scipy
import scipy.misc
from scipy.stats import gaussian_kde
import scipy.stats as stats
from scipy.stats import kurtosis

import skimage
from skimage import filters
from skimage import data, segmentation, color
from skimage.measure import label, regionprops
from skimage.color import label2rgb
from skimage.transform import rescale, resize, downscale_local_mean

# Libraries for graph visualization
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
from mpl_toolkits.mplot3d import Axes3D
import seaborn as sns

import os #File handling and operating system paths
from math import pi

# Mount google drive where the images are stored
from google.colab import drive
drive.mount('/content/drive')

"""## Project Function Definition"""

# Function to apply a filter to the image
def img_filtered(path_img_save, name_img, src):
  # Apply a median filter to reduce noise in the image
  src_denoised = filters.median(src,footprint=np.ones((5,5))) # median filter

  # Visualize the original and filtered image
  fig = plt.figure(figsize=(12,8), dpi=80)
  plt.subplot(121)
  plt.imshow(src,cmap='Greys_r') # Original grayscale image
  plt.title('Source image') # Title for the original image
  plt.subplot(122)
  plt.imshow(src_denoised) # Filtered image
  plt.title('Filtered image') # Title for the filtered image
  plt.tight_layout()

  # Save the image in the specified directory
  plt.savefig(f"{path_img_save}/{name_img.split('.')[0]}/img_filtered.png")

  plt.show()

  # Display the dimensions of the filtered image
  print(src_denoised.shape)

  return src_denoised

# Function to binarize the image
def binary_img(path_img_save, name_img, src, src_denoised, umbral):
  # Binarization of the image to calculate areas
  # Binarization threshold: pixels with a value greater than 'threshold' are turned white (255) and the rest black (0)
  ret, thresh = cv2.threshold(src_denoised,umbral,255,cv2.THRESH_BINARY)
  # Invert the colors so that light areas become black and dark areas become white
  thresh = 255-thresh

  # Calculate the histogram of the binarized image
  hist, bin_edges = np.histogram(thresh.reshape(-1,1),density=False)

  # Visualize the binarized image and its histogram
  fig = plt.figure(figsize=(12,4), dpi=80)
  plt.subplot(121)
  plt.imshow(src,cmap='viridis')
  plt.imshow(thresh,alpha=0.5,cmap='viridis')
  plt.title('Binary image')
  plt.subplot(122)
  n, bins, patches = plt.hist(thresh.reshape(-1,1),10,density=False,facecolor='g',alpha=0.75)
  plt.xlabel('Bins')
  plt.ylabel('Occurence \ Pixels')
  plt.title('Histogram of binarized image')
  plt.grid(True)
  plt.tight_layout()

  # Save the figure containing the binarized image and its histogram
  plt.savefig(f"{path_img_save}/{name_img.split('.')[0]}/binary_img.png")

  plt.show()

  # Save the results of the binarized image area analysis in a text file
  with open(path_img_save + '/' + name_img.split('.')[0] + '/' + 'results.txt', 'w') as f:
    f.write('Total image area = {} px2\n'.format(src.shape[0]*src.shape[1]))
    f.write('Total light area = {} px2\n'.format(hist[0]))
    f.write('Total dark area = {} px2\n'.format(hist[-1]))
    f.write('Fraction = {} % (dark/light)\n'.format(100*hist[-1]/hist[0]))

    f.close()

  # Display the results in the console
  print("\nSource image area = {} px".format(src.shape[0]*src.shape[1]))
  print("\nTotal light area = {} px2".format(hist[0]))
  print("Total dark area = {} px2".format(hist[-1]))
  print("\nFraction = {} %".format(100*hist[-1]/hist[0]))

  return thresh # Return the binarized image

def img_capture(path_img_save, name_img, src, thresh, max_area:int, min_area:int, critical_eccentricity:int):
  # Labeling and analysis of detected pores
  label_image = label(thresh)
  image_label_overlay = label2rgb(label_image, image=src)

  # Initialization of lists to store pore properties (circular and elliptical)
  area_of_circular_pores = []
  area_of_elliptical_pores = []
  perimeter_of_circular_pores = []
  perimeter_of_elliptical_pores = []
  equivalent_circular_diameter = [] # Only for circular pores
  eccentricity_of_circular_pores = []
  eccentricity_of_elliptical_pores = []

  # Counters for circular and elliptical pore
  number_of_circular_pores = 0
  number_of_elliptical_pores = 0
  total_number_of_pores = 0

  # Figure setup to visualize the pores
  fig = plt.figure(figsize=(10,8))
  ax = fig.add_subplot(111)
  ax.imshow(src,cmap='gray')
  ax.imshow(label_image,cmap='gray',alpha=0.5)

  # Iterate through each labeled region (pore)
  for region in regionprops(label_image):
      total_number_of_pores = total_number_of_pores + 1 # Increment the total pore counter
      plt.scatter(region.centroid[1],region.centroid[0],marker='x',s=40,c='crimson') # Mark the centroid of the pore

      # Filter pores based on area
      if (region.area <= max_area and region.area >= min_area):
          plt.scatter(region.centroid[1],region.centroid[0],marker='+',s=100,c='gold') # Mark selected pores
          minr, minc, maxr, maxc = region.bbox # Obtain the bounding box of the pore

          # Classify the pore as circular or elliptical based on its eccentricity
          if(region.eccentricity < critical_eccentricity): # Circular pore
              rect = mpatches.Rectangle((minc,minr),maxc-minc,maxr-minr,
                                    fill=False, edgecolor='springgreen', linewidth=2)
              number_of_circular_pores = number_of_circular_pores + 1 # Increment the circular pore counter
              area_of_circular_pores.append(region.area)
              equivalent_circular_diameter.append(region.equivalent_diameter)
              perimeter_of_circular_pores.append(region.perimeter)
              eccentricity_of_circular_pores.append(region.eccentricity)

          else: #Elliptical pore
              rect = mpatches.Rectangle((minc,minr),maxc-minc,maxr-minr,
                                    fill=False, edgecolor='royalblue', linewidth=2)
              number_of_elliptical_pores = number_of_elliptical_pores + 1 # Increment the elliptical pore counter
              area_of_elliptical_pores.append(region.area)
              perimeter_of_elliptical_pores.append(region.perimeter)
              eccentricity_of_elliptical_pores.append(region.eccentricity)

          # Add the bounding box to the visualization


  ax.set_title('Labeled and measured pores') # Title of the figure
  plt.tight_layout()

  # Save the figure showing pore detection
  plt.savefig(f"{path_img_save}/{name_img.split('.')[0]}/pore_recognition.png")
  plt.show()


# ================== Information on Pixel Conversion given the Zoom ============================
# 50 um
# 	1px   = x  microns
# 	508px = 50 micras  --> 1px = 0.098 microns

# 200 um
# 	1px   = x microns
# 	408px = 200 micras --> 1px = 0.490 microns

# 600-50 um
# 	1px   = x microns
# 	308px = 50 microns  --> 1px = 0.162

# ==============================================================================================


# Correction factor based on image zoom
  try:
    zoom = int(name_img.split("_")[-1][:-4]) # Obtain the zoom value of the image from its name

    if zoom == 50:
      factor_c = 0.098 # Correction factor for 50 µm images
    elif zoom == 200:
      factor_c = 0.490 # Correction factor for 200 µm images

  except:
    factor_c = 1.0 # Default correction factor if zoom is not specified

  #factor_c = 0.162

  # Save the results of the pore analysis in a text file
  with open(path_img_save + '/' + name_img.split('.')[0] + '/' + 'results.txt', 'a') as f:
    f.write('Number of circular pores: {}\n'.format(number_of_circular_pores))
    f.write('Number of elliptical pores: {}\n'.format(number_of_elliptical_pores))
    f.write('Number of ignored pores: {}\n'.format(total_number_of_pores-(number_of_elliptical_pores+number_of_circular_pores)))
    f.write('Total number of pores: {}\n'.format(total_number_of_pores))

    # Save the perimeter and area of circular and elliptical pores
    f.write('Total perimeter of circular pores: {} px\n'.format(int(np.sum(perimeter_of_circular_pores))))
    f.write('Total perimeter of elliptical pores: {} px\n'.format(int(np.sum(perimeter_of_elliptical_pores))))
    f.write('Total area of circular pores: {} px2\n'.format(int(np.sum(area_of_circular_pores))))
    f.write('Total area of elliptical pores: {} px2\n'.format(int(np.sum(area_of_elliptical_pores))))
    f.write('Circular pore fraction: {} %\n'.format(100*int(np.sum(area_of_circular_pores))/(src.shape[0]*src.shape[1])))
    f.write('Elliptical pore fraction: {} %\n'.format(100*int(np.sum(area_of_elliptical_pores))/(src.shape[0]*src.shape[1])))

    # Save the average equivalent diameter and standard deviation of circular and elliptical pores
    try:
      f.write('Mean equivalent diameter of circular pores: {} um\n'.format(factor_c*int(np.mean(perimeter_of_circular_pores))/pi))
    except:
      f.write('Mean equivalent diameter of circular pores: NaN um\n')
    try:
      f.write(f'Std diameter of circular pores: {np.std([factor_c*(x/pi) for x in perimeter_of_circular_pores])} um\n')
    except:
      f.write('Std diameter of circular pores: NaN um\n')
    f.write('\n')

    try:
      f.write('Mean equivalent diameter of elliptical pores: {} um\n'.format(factor_c*int(np.mean(perimeter_of_elliptical_pores))/pi))
    except:
      f.write('Mean equivalent diameter of elliptical pores: NaN um\n')
    try:
      f.write(f'Std diameter of elliptical pores: {np.std([factor_c*(x/pi) for x in perimeter_of_elliptical_pores])} um\n')
    except:
      f.write('Std diameter of elliptical pores: NaN um\n')

    f.close()


  # Save the diameters, perimeters, and areas of circular and elliptical pores in lists

  try:
    diameter_of_circular_pores = [factor_c*(x/pi) for x in perimeter_of_circular_pores]
    perimeter_of_circular_pores = [factor_c*x for x in perimeter_of_circular_pores]
    area_of_circular_pores = [factor_c*factor_c*x for x in area_of_circular_pores]
  except:
    diameter_of_circular_pores = [np.nan]
    perimeter_of_circular_pores = [np.nan]
    area_of_circular_pores = [np.nan]


  try:
    diameter_of_elliptical_pores = [factor_c*(x/pi) for x in perimeter_of_elliptical_pores]
    perimeter_of_elliptical_pores = [factor_c*x for x in perimeter_of_elliptical_pores]
    area_of_elliptical_pores = [factor_c*factor_c*x for x in area_of_elliptical_pores]
  except:
    diameter_of_elliptical_pores = [np.nan]
    perimeter_of_elliptical_pores = [np.nan]
    area_of_elliptical_pores = [np.nan]

  # Return the results of the pore analysis as a dictionary
  results_capture = {
      'diameter_of_circular_pores': diameter_of_circular_pores,
      'perimeter_of_circular_pores': perimeter_of_circular_pores,
      'area_of_circular_pores': area_of_circular_pores,
      'diameter_of_elliptical_pores': diameter_of_elliptical_pores,
      'perimeter_of_elliptical_pores': perimeter_of_elliptical_pores,
      'area_of_elliptical_pores': area_of_elliptical_pores
  }

  return results_capture

# Function to plot the porosity distribution

def distribucion_porosidad(path_img_save, name_img, area_poros, tipo_poro):

  #Calculate percentiles for the box plot
  q1 = np.percentile(area_poros, 25) # First quartile (25%)
  q3 = np.percentile(area_poros, 75) # Third quartile (75%)
  iqr = q3 - q1 # Interquartile range
  upper_bound = q3 + 1.5 * iqr # Set the upper limit using the interquartile range

  # Obtenemos todos los valores menores o iguales al nuevo limite.
  subset_data = [x for x in area_poros if x <= upper_bound]

  # Create partitions with 0.5 intervals for the histogram
  bins = np.arange(0, np.max(subset_data) + 0.5, 0.5)

  # Obtain the code from the name to determine the color
  cod = name_img.split('_')[0]

  # Set the color of the smoothing line based on the code from the image name
  color_linea = 'red'  # Default value
  if cod in ['P-WO', 'EI-WO']:
      color_linea = 'purple'  # Purple
  elif cod in ['P-G1650', 'EI-G1650']:
      color_linea = 'magenta'  # Magenta
  elif cod in ['P-G1652', 'EI-G1652']:
      color_linea = 'navy'  # Navy blue
  elif cod in ['P-C1010', 'EI-C1010']:
      color_linea = 'orange'  # Orange

  # Set the figure size
  plt.figure(figsize=(12, 6))

  # Histogram with colored bars and transparency
  plt.hist(subset_data, bins=bins, edgecolor='black', color='lightblue', alpha=0.2)

  # Add a smoothing line using KDE (Kernel Density Estimation)
  kde = gaussian_kde(subset_data)
  x_vals = np.linspace(min(subset_data), max(subset_data), 100)
  plt.plot(x_vals, kde(x_vals) * len(subset_data) * (bins[1] - bins[0]), color=color_linea, linewidth=2)

  # Add labels and title
  plt.xticks(bins)
  plt.title(f'Histogram - {tipo_poro} - {cod}')
  plt.xlabel('um')
  plt.ylabel('Frequency')

  plt.tight_layout()

  # Save the figure in the specified directory
  plt.savefig(f"{path_img_save}/{name_img.split('.')[0]}/Distribucion_{tipo_poro}.png")

  plt.show()

# Function to generate a 3D relief map
def relief_map(path_img_save, name_img, src):
  # Resize the image to make processing more efficient
  src_resized = resize(src, (src.shape[0]//10,src.shape[1]//10),anti_aliasing=True)

  # Display the original and resized dimensions
  print(src.shape)
  print(src_resized.shape)

  # Generate the grid for the 3D plot
  xx, yy = np.mgrid[0:src_resized.shape[0],0:src_resized.shape[1]]

  # Set up the 3D figure to visualize the image relief
  fig = plt.figure(figsize=(14,10), dpi=80,)
  ax = plt.axes(projection='3d')
  ax.plot_surface(xx,yy,src_resized,rstride=1,cstride=1,cmap='jet',linewidth=1)
  ax.set_title('Surface Roughness')

  # Save the relief map image in the specified directory
  plt.savefig(f"{path_img_save}/{name_img.split('.')[0]}/heat_map.png")

  plt.show()

  return src_resized

# Function to partition the image into a grid of sliding windows
def img_partition(path_img_save, name_img, src_resized, window_size:int):
  window_size = 21 # Sliding window

  # Define the window limits
  x_start = 0
  x_stop = np.shape(src_resized)[1] # number of columns
  y_start = 0
  y_stop = np.shape(src_resized)[0] # number of rows

  # Set up the figure to display the image with the partition grid
  fig = plt.figure(figsize=(14,10), dpi=80)
  ax = fig.add_subplot(111)
  ax.imshow(src_resized,cmap='gray') # Display the resized grayscale image

  # Draw the image with the partition grid
  for i in range((int)((x_stop-x_start)/window_size)):
      for j in range((int)((y_stop-y_start)/window_size)):
          rect = mpatches.Rectangle((i*window_size,j*window_size),window_size,window_size,\
                                  linewidth=1,edgecolor='red',facecolor='none')

          ax.add_patch(rect)

  # Save the image with the partition grid
  plt.savefig(f"{path_img_save}/{name_img.split('.')[0]}/img_grid.png")

  plt.show()

  # Initialize a list to store the histograms of each partition
  hist_data = []

  # Extract histograms from each partition
  for i in range((int)((x_stop - x_start) / window_size)):
      for j in range((int)((y_stop - y_start) / window_size)):
          hist_data.append(src_resized[i * window_size : window_size * (i + 1), j * window_size : window_size * (j + 1)])

  # Print the number of partitions generated
  print("number of crops = " + str(len(hist_data)))

  # If there are partitions, display the shape of the first one
  if len(hist_data) > 0:
      print("shape of first crop = " + str(hist_data[0].shape))

  # Display the image partitions

  fig = plt.figure(figsize=(12,12), dpi=80)
  for i in range(len(hist_data)):
      plt.subplot((int)((x_stop-x_start)/window_size),(int)((y_stop-y_start)/window_size),i+1)
      plt.imshow(hist_data[i], cmap='gray')
      plt.title((str)(i))
      plt.axis('off')
  plt.tight_layout()

  # Save the image with the partitions
  plt.savefig(f"{path_img_save}/{name_img.split('.')[0]}/img_partition.png")

  plt.show()


  # Display the histograms of each partition
  fig = plt.figure(figsize=(12,12), dpi=80)
  for i in range(len(hist_data)):
      hist, bins = np.histogram(hist_data[i],bins=20,density=True)
      width = 0.7 * (bins[1] - bins[0])
      center = (bins[:-1] + bins[1:]) / 2
      plt.subplot((int)((x_stop-x_start)/window_size),(int)((y_stop-y_start)/window_size),i+1),

      plt.bar(center, hist, align='center', width=width),plt.title((str)(i)) # hist of the cropped rregion

  # Save the image containing the histograms of each partition
  plt.savefig(f"{path_img_save}/{name_img.split('.')[0]}/histograma_img_partition.png")

  plt.show()

  return hist_data

# Function to generate heatmaps of the mean and standard deviation of the partitions
def mean_std_heat_map(path_img_save, name_img, hist_data):
  # Lists to store the means and standard deviations of each partition
  mean_list = []
  std_dev_list = []

  # Calculate the mean and standard deviation for each partition
  for i in range(len(hist_data)):
      mean_list.append(np.mean(hist_data[i]))
      std_dev_list.append(np.std(hist_data[i]))

  # Reshape the lists into matrices to generate the heatmaps
  heat_map_mean = np.reshape(mean_list,(6, 4)) # Modify according to the size of the partition matrix
  heat_map_std = np.reshape(std_dev_list,(6, 4))

  (iH, iW) = heat_map_mean.shape[:2] # the same dimensions for heat_map_std

  # Setup to display the heatmap of the mean
  fig = plt.figure(figsize=(14,5), dpi=80)
  plt.subplot(121)
  plt.imshow(heat_map_mean),plt.colorbar()
  plt.title('Mean Heat Map')
  for i in range(iH):
      for j in range(iW):
          plt.text(j,i,np.round(heat_map_mean[i,j],2),ha="center",va="center",color="w",fontsize=20)

  # Mean plot
  plt.subplot(122)
  plt.title('Mean plot')
  plt.plot(np.reshape(heat_map_mean,(iH*iW,1)),label='Mean values',linewidth=3)
  plt.xlabel('Patch Number'),plt.ylabel('Mean Value')
  plt.grid(),plt.legend()
  plt.tight_layout()

  plt.savefig(f"{path_img_save}/{name_img.split('.')[0]}/mean_heat_map.png")

  plt.show()

  # Setup to display the heatmap of the standard deviation
  fig = plt.figure(figsize=(14,5), dpi=80)
  plt.subplot(121)
  plt.imshow(heat_map_std),plt.colorbar()
  plt.title('Std Heat Map')
  for i in range(iH):
      for j in range(iW):
          plt.text(j,i,np.round(heat_map_std[i,j],2),ha="center",va="center",color="w",fontsize=20)

  # Standard deviation plot
  plt.subplot(122)
  plt.title('Std plot')
  plt.plot(np.reshape(heat_map_std,(iH*iW,1)),label='Std values',linewidth=3)
  plt.xlabel('Patch Number'),plt.ylabel('Std Value')
  plt.grid(),plt.legend()
  plt.tight_layout()

  plt.savefig(f"{path_img_save}/{name_img.split('.')[0]}/std_heat_map.png")

  plt.show()

  # Generate a plot comparing the mean and standard deviation values
  fig = plt.figure(figsize=(8,3))
  ax1 = fig.add_subplot(111)

  color = 'tab:red'
  ax1.set_xlabel('Patch number')
  ax1.set_ylabel('Mean value', color=color)
  ax1.plot(np.reshape(heat_map_mean,(iH*iW,1)),label='Mean values',linewidth=3,color=color)
  ax1.tick_params(axis='y',labelcolor=color)
  plt.grid()

  ax2 = ax1.twinx() # Create a second Y-axis for the standard deviation
  color = 'tab:blue'
  ax2.set_ylabel('Std value', color=color)
  ax2.plot(np.reshape(heat_map_std,(iH*iW,1)),label='Mean values',linewidth=3,color=color)
  ax2.tick_params(axis='y',labelcolor=color)

  fig.tight_layout()

  # Save the comparative image of the mean and standard deviation
  plt.savefig(f"{path_img_save}/{name_img.split('.')[0]}/relation_mean_std.png")
  plt.show()

# Generate the paths where we will find the images and store the results
route = '/content/drive/MyDrive/Colab Notebooks/Proyecto_Catalina/Prueba'
# Path where we will store the images to be analyzed
route_img = route + '/imgs'
# Path where we will store the analysis results
name_results = 'results_prueba'
path_img_save = route + '/' + name_results

# Check if the results folder exists, if it does, delete it; otherwise, continue
try:
  os.listdir(route).remove(name_results)
except:
  pass

# Visualize the images in the directory to be analyzed
list_img = os.listdir(route_img)
list_img

global_results = pd.DataFrame()

for name_img in list_img:
  src = cv2.imread(route_img+'/'+name_img, 0)[:-60,:]

  # Ensure the "results" folder exists; if not, create it...
  if not os.path.exists(path_img_save):
      os.makedirs(path_img_save)
  # Ensure the image folder exists; if not, create it...
  if not os.path.exists(path_img_save+'/'+name_img.split('.')[0]):
      os.makedirs(path_img_save+'/'+name_img.split('.')[0])

  # Visualize the image compared to a filter
  src_denoised = img_filtered(path_img_save, name_img, src)

  # Determine the binarization of the image (amount of light/shadow; 'threshold')
  thresh = binary_img(path_img_save, name_img, src, src_denoised, umbral=90)

  # Determine the maximum area, minimum area, and eccentricity of the pores
  results_capture = img_capture(path_img_save, name_img, src, thresh, max_area=50000, min_area=5, critical_eccentricity=0.6) # 0.6

  # Store the results of circular and elliptical pores in a DataFrame
  dict_results = {
      'Image': [name_img]*max(len(results_capture['diameter_of_circular_pores']), len(results_capture['diameter_of_elliptical_pores'])),
      'Diameter Circular Pores': pd.Series(results_capture['diameter_of_circular_pores']),
      'Perimeter Circular Pores': pd.Series(results_capture['perimeter_of_circular_pores']),
      'Area Circular Pores': pd.Series(results_capture['area_of_circular_pores']),
      'Diameter Elliptical Pores': pd.Series(results_capture['diameter_of_elliptical_pores']),
      'Perimeter Elliptical Pores': pd.Series(results_capture['perimeter_of_elliptical_pores']),
      'Area Elliptical Pores': pd.Series(results_capture['area_of_elliptical_pores'])
      }
  df_results = pd.DataFrame(dict_results)

  # Plot the distribution of pore areas (circular and elliptical)
  try:
    distribucion_porosidad(path_img_save, name_img, results_capture['diameter_of_circular_pores'], 'Circular Diameter')
  except:
    pass

  try:
    distribucion_porosidad(path_img_save, name_img, results_capture['diameter_of_elliptical_pores'], 'Elliptical Diameter')
  except:
    pass

  # Plot the image in 3D (with relief)
  src_resized = relief_map(path_img_save, name_img, src)

  # Generate the matrix/grid of the image to analyze it by sections/partitions
  hist_data = img_partition(path_img_save, name_img, src_resized, window_size=30)

  # Plot the mean, standard deviation, and the relationship between both, of the image relief
  mean_std_heat_map(path_img_save, name_img, hist_data)

  # Update the DataFrame with the new results
  global_results = pd.concat([global_results, df_results], axis=1)

# We visualize the first 5 results from the total results
global_results.head()

# We export the results obtained in an Excel file
global_results.reset_index(drop=True, inplace=True)
global_results.to_excel(path_img_save+'/global_results.xlsx')